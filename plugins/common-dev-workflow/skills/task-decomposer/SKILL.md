---
name: task-decomposer
description: "자연어 계획을 실행 가능한 구체적 태스크로 분해하는 스킬. 새 기능 개발, 리팩토링, 버그 수정 등 코딩 계획을 체크박스 마크다운으로 변환. 재귀적 분해, 의존성 매핑, 병렬화 웨이브 그룹핑, 진행 상태 추적, 검증 체크리스트 포함. 사용 시점: (1) 계획을 태스크로 분해할 때, (2) 태스크 만들어줘 요청 시, (3) 복잡한 개발 작업을 단계별로 나눌 때"
---

# Task Decomposer

자연어 계획을 실행 가능한 마크다운 태스크 목록으로 변환한다.

## 입력 형식

주로 **구조화된 계획**을 입력으로 받음:
- 단계별로 정리된 개발 계획
- 프로젝트 분석 결과 + 실행 계획
- 기술 설계 문서

기타 입력도 처리 가능:
- 자연어 요청 → 먼저 계획 수립 후 태스크 분해
- 이슈/티켓 내용 → 구조화하여 분해

## 스코프 관리

**대규모 계획 처리:**
- 태스크 20개 초과 예상 → Phase로 분리
- Phase별 별도 마크다운 파일 생성
- 파일명: `tasks-phase1-[기능명].md`, `tasks-phase2-[기능명].md`

**Phase 분리 기준:**
- 논리적 마일스톤 (MVP → 확장 → 최적화)
- 배포 단위 (독립 배포 가능한 단위)
- 의존성 경계 (외부 의존성 대기 필요 시)

## 핵심 원칙

### 재귀적 분해
- **리프 태스크 기준**: 단일 작업 단위(single unit of work)까지 분해
- **자동 깊이 판단**: "이 태스크를 더 쪼개면 의미있는가?" → No일 때 중단
- 리프 태스크 특성: 명확한 완료 조건, 30분 이내 완료 가능, 단일 파일/함수 수준

### 의존성 우선
- 블로킹 의존성 명시 (`blocked by: #task-id`)
- 병렬 실행 가능한 태스크는 같은 웨이브로 그룹핑
- 크리티컬 패스 식별

## 워크플로우

```
1. 계획 파싱 → 주요 작업 단위 식별
2. 재귀 분해 → 리프 태스크까지 세분화
3. 의존성 분석 → 선후 관계 매핑
4. 웨이브 그룹핑 → 병렬 실행 단위 구성
5. 검증 항목 추가 → 완료 조건/테스트 명시
6. 마크다운 생성 → 템플릿 기반 출력
```

## 분해 판단 기준

태스크가 다음 중 하나라도 해당하면 더 분해:

| 신호 | 예시 | 분해 방향 |
|------|------|----------|
| 여러 파일 수정 | "API와 프론트 연결" | 파일별 분리 |
| 복합 동사 | "생성하고 연결" | 동사별 분리 |
| 암묵적 단계 | "테스트 작성" | setup/작성/실행 분리 |
| 30분 초과 예상 | 대규모 리팩토링 | 컴포넌트별 분리 |

상세 패턴: [references/decomposition-patterns.md](references/decomposition-patterns.md)

## 의존성 & 웨이브

### 의존성 유형
- **Hard**: 반드시 선행 완료 필요 (DB 스키마 → 마이그레이션)
- **Soft**: 권장 순서 (테스트 → 구현도 가능하지만 구현 → 테스트 권장)

### 웨이브 구성
```
Wave 1: 의존성 없는 태스크 (병렬 실행)
Wave 2: Wave 1 완료 후 실행 가능한 태스크
Wave N: 이전 웨이브 의존 태스크
```

상세 규칙: [references/dependency-mapping.md](references/dependency-mapping.md)

## 출력 형식

### 필수 섹션
1. **Meta**: 프로젝트명, 생성일, 총 태스크 수
2. **Progress**: 진행률 표시
3. **Tasks by Wave**: 웨이브별 체크박스 목록
4. **Verification**: 최종 검증 체크리스트

### 태스크 항목 형식 (세분화된 체크박스)
```markdown
- [ ] **T-001**: [태스크 제목] ⏱️ 10분
  - 파일: `path/to/file.ts` (신규|수정)
  - 참조: `similar/file.ts`, `docs/plan/xxx.md#section`
  - 스킬: `code-refactoring` (선택, task-executor가 활용)
  - 작업:
    - [ ] 첫 번째 atomic 작업 (5분 이내)
    - [ ] 두 번째 atomic 작업
    - [ ] 세 번째 atomic 작업
  - 검증:
    - [ ] `실행 가능한 검증 명령어`
    - [ ] 수동 확인 항목 (필요시)
  - 롤백: `git checkout -- path/to/file.ts` (선택)
  - blocked by: T-000 (있는 경우)
```

### 태스크 형식 필드 설명

| 필드 | 필수 | 설명 |
|------|------|------|
| 파일 | ✅ | 대상 파일 경로 + (신규\|수정) 표시 |
| 참조 | ⭕ | 기존 코드 패턴, 계획서 링크 (패턴 따르기 원칙) |
| 스킬 | ⭕ | task-executor가 활용할 스킬 (available_skills에서 탐색) |
| 작업 | ✅ | **체크박스로 세분화된 atomic 단위** (5분 이내) |
| 검증 | ✅ | **실행 가능한 명령어** 우선, 수동 확인 최소화 |
| 롤백 | ⭕ | 실패 시 복구 명령 (DB 변경 등 위험 작업에 필수) |
| blocked by | ⭕ | 선행 의존성 |

### 작업 세분화 원칙

**각 서브스텝은 다음을 만족해야 함:**
- ✅ 5분 이내 완료 가능
- ✅ 단일 동작 (하나의 동사)
- ✅ 독립적으로 검증 가능
- ✅ 체크박스로 진행률 추적

**분해 예시:**
```
❌ 나쁨: "API 섹션 작성 (base_url, timeout, headers, retry 등)"
✅ 좋음:
  - [ ] base_url 설정 ("https://api.example.com")
  - [ ] timeout 설정 (30초)
  - [ ] headers 섹션 추가
  - [ ] retry 정책 설정
```

출력 템플릿: [assets/task-template.md](assets/task-template.md)

## 검증 규칙

각 태스크에 완료 조건 필수 포함:
- 테스트 통과 여부
- 빌드 성공 여부  
- 기능 동작 확인 방법

최종 검증 섹션에 통합 테스트 항목 추가.

상세 규칙: [references/validation-rules.md](references/validation-rules.md)

## 스킬 자동 제안 (task-executor 연동)

태스크 유형에 맞는 스킬을 자동으로 제안한다. task-executor가 이 스킬을 활용하여 전문 지식을 주입받고 작업을 수행한다.

### 스킬 제안 로직

```
태스크 제목/작업 내용 분석
    ↓
available_skills 스캔 (실행 시점)
    ↓
description 키워드 매칭
    ↓
관련 스킬 발견? → 스킬: `스킬명` 추가
    ↓
발견 안됨? → 스킬 필드 생략 (executor가 동적 탐색)
```

### 스킬 제안 예시

| 태스크 키워드 | 제안 스킬 (예시) |
|--------------|-----------------|
| 리팩토링, 코드 품질 | `code-refactoring` |
| API 설계, 엔드포인트 | `backend-development:api-design-principles` |
| 테스트, TDD | `backend-development:tdd-orchestrator` |
| 성능 최적화 | `application-performance:performance-engineer` |
| 보안 검토 | `comprehensive-review:security-auditor` |

**주의**: 스킬 목록은 동적으로 변경될 수 있으므로 하드코딩하지 않고 available_skills를 참조한다.

### 사용자 수정

제안된 스킬은 수정 가능:
```markdown
# 자동 제안
- 스킬: `code-refactoring`

# 사용자가 다른 스킬로 변경 가능
- 스킬: `python-development:python-pro`

# 또는 스킬 제거 (executor가 동적 탐색)
- (스킬 필드 삭제)
```

## 컨텍스트 활용

계획에 파일 경로나 코드 컨텍스트가 포함된 경우:
- 해당 파일 참조하여 구체적 라인/함수 수준으로 태스크 작성
- 기존 코드 구조에 맞춰 분해 단위 조정

계획만 있는 경우:
- 일반적인 프로젝트 구조 가정하여 분해
- 필요시 사용자에게 구조 확인 요청

## Quick Reference

### 좋은 리프 태스크
```markdown
- [ ] **T-003**: UserService에 validateEmail 메서드 추가
  - 파일: `src/services/user.service.ts`
  - 작업: 이메일 형식 검증 로직 구현 (regex 사용)
  - 완료 조건: `npm test -- user.service.spec.ts` 통과
```

### 나쁜 태스크 (더 분해 필요)
```markdown
- [ ] 사용자 인증 구현  ← 너무 추상적
- [ ] API 만들기  ← 범위 불명확
- [ ] 버그 수정하고 테스트  ← 복합 작업
```

## 태스크 수정 가이드

생성된 태스크 목록 변경 시:
- **스코프 변경**: 영향받는 의존성 재계산, 웨이브 재구성
- **태스크 삭제**: `blocked by` 참조하는 태스크 업데이트
- **태스크 분할**: 원본 ID 유지 (T-003 → T-003a, T-003b)
- **순서 변경**: 의존성 그래프 유효성 검증 후 웨이브 재배치
